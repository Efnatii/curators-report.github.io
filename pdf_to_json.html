<!DOCTYPE html>
<html lang="ru">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>PDF → JSON Конвертер</title>
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;600;700&display=swap" rel="stylesheet">
  <link rel="stylesheet" href="styles.css" />
  <style>
    body {
      background: radial-gradient(circle at 20% 20%, rgba(73, 115, 255, 0.07), transparent 30%),
                  radial-gradient(circle at 80% 0%, rgba(255, 133, 153, 0.07), transparent 28%),
                  #0e0f1a;
      color: #f5f7fb;
      min-height: 100vh;
    }

    .converter {
      max-width: 960px;
      margin: 0 auto;
      padding: 64px 24px 96px;
    }

    .converter__header {
      text-align: center;
      margin-bottom: 32px;
    }

    .converter__eyebrow {
      display: inline-flex;
      gap: 8px;
      align-items: center;
      padding: 8px 12px;
      border-radius: 999px;
      background: rgba(255, 255, 255, 0.08);
      color: #a0b4ff;
      font-weight: 600;
      letter-spacing: 0.02em;
      text-transform: uppercase;
      font-size: 13px;
    }

    .converter__title {
      font-size: clamp(32px, 5vw, 44px);
      margin: 16px 0 8px;
      line-height: 1.1;
    }

    .converter__lead {
      color: #c5cee6;
      max-width: 720px;
      margin: 0 auto;
      font-size: 18px;
    }

    .card {
      background: rgba(255, 255, 255, 0.04);
      border: 1px solid rgba(255, 255, 255, 0.08);
      border-radius: 16px;
      padding: 24px;
      box-shadow: 0 20px 60px rgba(0, 0, 0, 0.35);
      backdrop-filter: blur(6px);
    }

    .card + .card {
      margin-top: 16px;
    }

    .card__header {
      display: flex;
      align-items: center;
      gap: 12px;
      margin-bottom: 12px;
    }

    .card__icon {
      width: 38px;
      height: 38px;
      border-radius: 10px;
      background: linear-gradient(135deg, #486bff, #9a6bff);
      display: inline-flex;
      align-items: center;
      justify-content: center;
      color: #fff;
      font-weight: 700;
      box-shadow: 0 12px 30px rgba(88, 123, 255, 0.4);
    }

    .card__title {
      font-weight: 700;
      font-size: 18px;
      margin: 0;
    }

    .card__description {
      color: #d0d6ec;
      margin: 0 0 12px;
      font-size: 15px;
    }

    .field-row {
      display: grid;
      gap: 12px;
      grid-template-columns: 1fr 1fr;
      align-items: start;
    }

    .field {
      position: relative;
      display: grid;
      gap: 6px;
    }

    .field label {
      font-weight: 600;
      color: #e4e9f5;
    }

    .field input[type="file"] {
      border: 1px dashed rgba(255, 255, 255, 0.25);
      background: rgba(255, 255, 255, 0.03);
      padding: 12px;
      border-radius: 12px;
      color: #f5f7fb;
      cursor: pointer;
      transition: border-color 120ms ease, background 120ms ease;
    }

    .field input[type="file"]:hover {
      border-color: rgba(255, 255, 255, 0.4);
      background: rgba(255, 255, 255, 0.06);
    }

    .field input[type="file"]::file-selector-button {
      background: linear-gradient(120deg, #6c8cff, #4f61ff);
      border: none;
      color: #fff;
      padding: 10px 14px;
      margin-right: 12px;
      border-radius: 10px;
      font-weight: 600;
      cursor: pointer;
      box-shadow: 0 10px 24px rgba(84, 114, 255, 0.35);
      transition: transform 120ms ease, box-shadow 120ms ease;
    }

    .field input[type="file"]::file-selector-button:hover {
      transform: translateY(-1px);
      box-shadow: 0 12px 28px rgba(84, 114, 255, 0.4);
    }

    .field input[type="text"] {
      border: 1px solid rgba(255, 255, 255, 0.1);
      background: rgba(255, 255, 255, 0.06);
      padding: 12px;
      border-radius: 12px;
      color: #f5f7fb;
    }

    .button-row {
      display: flex;
      flex-wrap: wrap;
      gap: 12px;
      margin-top: 12px;
    }

    .button-row .button {
      padding: 12px 18px;
      border-radius: 12px;
      font-weight: 600;
      border: none;
      cursor: pointer;
      transition: transform 120ms ease, box-shadow 120ms ease;
    }

    .button:disabled {
      opacity: 0.6;
      cursor: not-allowed;
      transform: none;
      box-shadow: none;
    }

    .button--primary {
      background: linear-gradient(120deg, #6c8cff, #4f61ff);
      color: #fff;
      box-shadow: 0 14px 32px rgba(84, 114, 255, 0.4);
    }

    .button--ghost {
      background: rgba(255, 255, 255, 0.06);
      color: #e4e9f5;
      border: 1px solid rgba(255, 255, 255, 0.08);
    }

    .button:hover:not(:disabled) {
      transform: translateY(-1px);
      box-shadow: 0 12px 26px rgba(0, 0, 0, 0.25);
    }

    .output-area {
      width: 100%;
      min-height: 260px;
      background: rgba(0, 0, 0, 0.35);
      color: #e9ecf7;
      border: 1px solid rgba(255, 255, 255, 0.08);
      border-radius: 12px;
      padding: 14px;
      font-family: "JetBrains Mono", "SFMono-Regular", Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace;
      font-size: 13px;
      line-height: 1.4;
      resize: vertical;
    }

    .badge {
      display: inline-flex;
      align-items: center;
      gap: 8px;
      padding: 8px 12px;
      background: rgba(80, 214, 125, 0.12);
      color: #4af18b;
      border-radius: 12px;
      font-weight: 600;
      font-size: 13px;
    }

    .status {
      margin-top: 10px;
      color: #c5cee6;
      font-size: 14px;
    }

    @media (max-width: 720px) {
      .field-row {
        grid-template-columns: 1fr;
      }

      .converter {
        padding: 48px 16px 72px;
      }
    }
  </style>
</head>
<body>
  <div class="converter">
    <header class="converter__header">
      <div class="converter__eyebrow">
        <span>Утилита</span>
        <span aria-hidden="true">•</span>
        <span>PDF → JSON</span>
      </div>
      <h1 class="converter__title">Преобразование PDF в JSON</h1>
      <p class="converter__lead">Загрузите PDF-файл и получите структурированный JSON c текстом каждого листа. Интерфейс и валидация основаны на логике из основной анкеты.</p>
    </header>

    <section class="card" aria-labelledby="input-card-title">
      <div class="card__header">
        <div class="card__icon">1</div>
        <div>
          <h2 id="input-card-title" class="card__title">Файл для конвертации</h2>
          <p class="card__description">Поддерживаются документы в формате PDF. Файл читается только в вашем браузере.</p>
        </div>
      </div>

      <div class="field-row">
        <div class="field">
          <label for="pdf-file">Выберите PDF</label>
          <input type="file" id="pdf-file" accept="application/pdf" />
          <p class="status" id="file-status">Файл не выбран</p>
        </div>
        <div class="field">
          <label for="output-name">Имя выходного файла</label>
          <input type="text" id="output-name" placeholder="Например, Отчет_о_кураторской_деятельности.json" />
          <p class="status">Если оставить поле пустым, имя будет сгенерировано автоматически.</p>
        </div>
      </div>

      <div class="button-row">
        <button class="button button--primary" id="convert-button" disabled>Конвертировать</button>
        <button class="button button--ghost" id="download-button" disabled>Скачать JSON</button>
      </div>
    </section>

    <section class="card" aria-labelledby="output-card-title">
      <div class="card__header">
        <div class="card__icon">2</div>
        <div>
          <h2 id="output-card-title" class="card__title">Результат конвертации</h2>
          <p class="card__description">Готовый JSON можно скопировать вручную или сохранить через кнопку скачивания.</p>
        </div>
      </div>

      <textarea class="output-area" id="json-output" aria-label="JSON результат" readonly placeholder="Здесь появится результат..."></textarea>
      <div class="status" id="conversion-status">Ожидаю загрузку файла.</div>
      <div class="badge" id="page-count" hidden>Страниц: 0</div>
    </section>
  </div>

  <script>
    const pdfInput = document.getElementById('pdf-file');
    const outputNameInput = document.getElementById('output-name');
    const convertButton = document.getElementById('convert-button');
    const downloadButton = document.getElementById('download-button');
    const jsonOutput = document.getElementById('json-output');
    const conversionStatus = document.getElementById('conversion-status');
    const fileStatus = document.getElementById('file-status');
    const pageCountBadge = document.getElementById('page-count');

    const pdfLibraryCandidates = [
      'https://cdnjs.cloudflare.com/ajax/libs/pdf.js/4.2.67/pdf.min.mjs',
      'https://unpkg.com/pdfjs-dist@4.2.67/build/pdf.min.mjs',
      'https://cdn.jsdelivr.net/npm/pdfjs-dist@4.2.67/+esm',
    ];

    let pdfJsReady = typeof window.pdfjsLib !== 'undefined';
    let pdfWorkerReady = false;
    const workerCandidates = [
      'https://cdnjs.cloudflare.com/ajax/libs/pdf.js/4.2.67/pdf.worker.min.mjs',
      'https://cdnjs.cloudflare.com/ajax/libs/pdf.js/4.2.67/pdf.worker.mjs',
      'https://cdn.jsdelivr.net/npm/pdfjs-dist@4.2.67/build/pdf.worker.min.mjs',
      'https://cdn.jsdelivr.net/npm/pdfjs-dist@4.2.67/build/pdf.worker.mjs',
      'https://unpkg.com/pdfjs-dist@4.2.67/build/pdf.worker.min.mjs',
      'https://unpkg.com/pdfjs-dist@4.2.67/build/pdf.worker.mjs',
    ];

    function loadPdfLibrary(url) {
      if (url.endsWith('.mjs') || url.includes('+esm')) {
        return import(url)
          .then((module) => {
            window.pdfjsLib = module;
            return true;
          })
          .catch(() => Promise.reject(new Error(`Failed to import module: ${url}`)));
      }

      return new Promise((resolve, reject) => {
        const script = document.createElement('script');
        script.src = url;
        script.async = true;
        script.onload = () => resolve(true);
        script.onerror = () => reject(new Error(`Failed to load script: ${url}`));
        document.head.appendChild(script);
      });
    }

    async function ensurePdfJs() {
      if (pdfJsReady) return true;

      for (const candidate of pdfLibraryCandidates) {
        try {
          await loadPdfLibrary(candidate);
          if (typeof window.pdfjsLib !== 'undefined') {
            pdfJsReady = true;
            return true;
          }
        } catch (error) {
          // Переходим к следующему кандидату.
        }
      }

      setConversionState('Не удалось загрузить библиотеку PDF.js. Проверьте подключение к интернету и обновите страницу.', true);
      convertButton.disabled = true;
      return false;
    }

    async function ensurePdfWorker() {
      if (!pdfJsReady) {
        setConversionState('Не удалось загрузить библиотеку PDF.js. Проверьте подключение к интернету и обновите страницу.', true);
        convertButton.disabled = true;
        return false;
      }

      for (const candidate of workerCandidates) {
        try {
          const response = await fetch(candidate, { method: 'HEAD' });
          if (response.ok) {
            pdfjsLib.GlobalWorkerOptions.workerSrc = candidate;
            return true;
          }
        } catch (error) {
          // Переходим к следующему кандидату.
        }
      }

      setConversionState('Не удалось загрузить worker PDF.js. Проверьте подключение к интернету и попробуйте еще раз.', true);
      convertButton.disabled = true;
      return false;
    }

    function updateConvertAvailability() {
      const hasFile = Boolean(pdfInput.files && pdfInput.files.length);
      convertButton.disabled = !(hasFile && pdfWorkerReady);
    }

    async function bootstrapPdfJs() {
      setConversionState('Загружаю библиотеку PDF.js...');
      pdfJsReady = await ensurePdfJs();
      pdfWorkerReady = pdfJsReady ? await ensurePdfWorker() : false;
      updateConvertAvailability();
    }

    bootstrapPdfJs();

    function generateFileName(pdfName = 'document.pdf') {
      const baseName = pdfName.replace(/\.pdf$/i, '') || 'document';
      return `${baseName.replace(/\s+/g, '_')}.json`;
    }

    function setConversionState(message, isError = false) {
      conversionStatus.textContent = message;
      conversionStatus.style.color = isError ? '#ffb4c0' : '#c5cee6';
    }

    function normalizeLine(text = '') {
      return text.replace(/^[•\-\u2022]\s*/, '').replace(/\s+/g, ' ').trim();
    }

    async function extractPageLines(pdf, pageNumber) {
      const page = await pdf.getPage(pageNumber);
      const content = await page.getTextContent({ normalizeWhitespace: true });
      const lines = [];
      let currentLine = '';

      content.items.forEach((item) => {
        currentLine += item.str;

        if (item.hasEOL) {
          lines.push(normalizeLine(currentLine));
          currentLine = '';
        } else {
          currentLine += ' ';
        }
      });

      if (currentLine.trim()) {
        lines.push(normalizeLine(currentLine));
      }

      return lines.filter(Boolean);
    }

    function parseBooleanAnswer(answer = '') {
      const normalized = answer.trim().toLowerCase();
      if (normalized === 'да') return true;
      if (normalized === 'нет') return false;
      return null;
    }

    function parseList(text = '') {
      if (!text || text === '—') return [];
      return text
        .split(',')
        .map((item) => item.trim())
        .filter(Boolean);
    }

    function mergeNumberedLines(lines = []) {
      const merged = [];
      let current = '';

      lines.forEach((line) => {
        const trimmed = line.trim();
        const isNumbered = /^\d+\.\s*/.test(trimmed);

        if (isNumbered) {
          if (current) merged.push(current.trim());
          current = trimmed;
        } else if (current) {
          current = `${current} ${trimmed}`.trim();
        } else if (trimmed) {
          current = trimmed;
        }
      });

      if (current) merged.push(current.trim());
      return merged;
    }

    function parseDateRange(text = '') {
      if (!text || text === '—') return { start: '', end: '' };
      const [start, end] = text.split('—').map((value) => value.trim());
      return { start: start || '', end: end || '' };
    }

    function escapeForRegex(text = '') {
      return text.replace(/[.*+?^${}()|[\]\\]/g, '\\$&');
    }

    function extractLabeledValue(text = '', label = '') {
      if (!text || !label) return '';
      const pattern = new RegExp(`${escapeForRegex(label)}:\s*([^,]+)`, 'i');
      const match = text.match(pattern);
      return match ? match[1].trim() : '';
    }

    function parseReportingPeriod(answer = '') {
      const deadlineMatch = answer.match(/\(Прислать отчёт до ([^)]+)\)/);
      const deadline = deadlineMatch ? deadlineMatch[1].trim() : '';
      const withoutDeadline = deadline ? answer.replace(deadlineMatch[0], '').trim() : answer;
      const [labelPart, rangePart = ''] = withoutDeadline.split(':').map((value) => value.trim());
      const rangeValue = rangePart || labelPart;
      const { start, end } = parseDateRange(rangeValue);

      return {
        label: rangePart ? labelPart : '',
        date_start: start,
        date_end: end,
        deadline,
        display: answer,
        range: rangeValue,
      };
    }

    const questionOrder = [
      { key: 'reporting_period', label: 'Отчетный период', type: 'line', parse: parseReportingPeriod },
      { key: 'full_name', label: '1. Фамилия Имя Отчество *', type: 'line' },
      { key: 'job_positions', label: '2. Должность *', type: 'list', parseItem: (item) => item || null },
      { key: 'department', label: '3. Кафедра *', type: 'line' },
      {
        key: 'contact_phone_connected_to_telegram',
        label: '4. Контактный телефон (подключенный к Telegram) *',
        type: 'line',
      },
      { key: 'telegram_username', label: '5. Ник в Telegram *', type: 'line' },
      { key: 'email', label: '6. E-mail *', type: 'line' },
      { key: 'curated_group_numbers', label: '7. Номера курируемых групп *', type: 'list', parseItem: (item) => item || null },
      { key: 'curator_primary_building', label: '8. Корпус основного пребывания куратора *', type: 'line' },
      { key: 'curator_primary_room', label: '9. Аудитория основного пребывания куратора *', type: 'line' },
      { key: 'institute_or_faculty', label: '10. Институт/Факультет *', type: 'list', parseItem: (item) => item || null },
      {
        key: 'held_minimum_three_curator_sessions_in_reporting_period',
        label: '11. Проведение не менее трех кураторских часов за отчетный период *',
        type: 'boolean',
      },
      {
        key: 'curator_hours_details',
        label: '12. Даты проведения трех и более кураторских часов в течение отчетного периода',
        type: 'list',
        parseItem: (text) => {
          const groups = parseList(extractLabeledValue(text, 'Группы'));
          const specialists = parseList(extractLabeledValue(text, 'Специалисты'));
          const { start: date_start, end: date_end } = parseDateRange(extractLabeledValue(text, 'Период'));
          const directions = parseList(extractLabeledValue(text, 'Направления'));
          const topic = extractLabeledValue(text, 'Тема');
          if (!groups.length && !specialists.length && !date_start && !date_end && !directions.length && !topic) return null;
          return { groups, specialists, date_start, date_end, directions, topic };
        },
      },
      {
        key: 'manages_group_chat',
        label: '13. Ведение чата с каждой группой или общего чата со всеми группами *',
        type: 'boolean',
      },
      {
        key: 'inform_group_about_events',
        label: '14. Информирование группы о мероприятиях и событиях различного уровня *',
        type: 'boolean',
      },
      {
        key: 'achievements',
        label: '15. Призовое место обучающегося во внеучебных мероприятиях, конкурсах, получение грантов',
        type: 'list',
        parseItem: (text) => {
          const { start: date_start, end: date_end } = parseDateRange(extractLabeledValue(text, 'Период'));
          const event = extractLabeledValue(text, 'Событие');
          const group = extractLabeledValue(text, 'группа');
          const student = extractLabeledValue(text, 'студент(ы)');
          const result = extractLabeledValue(text, 'результат');
          const directions = parseList(extractLabeledValue(text, 'направленность'));
          if (!date_start && !date_end && !event && !group && !student && !result && !directions.length) return null;
          return { date_start, date_end, event, group, student, result, directions };
        },
      },
      {
        key: 'participated_in_two_events_with_group',
        label: '16. Совместное участие с группой не менее чем в двух мероприятиях в течение отчетного периода *',
        type: 'boolean',
      },
      {
        key: 'joint_participation_events',
        label: '17. Даты проведения двух и более мероприятий в течение отчетного периода',
        type: 'list',
        parseItem: (text) => {
          const groups = parseList(extractLabeledValue(text, 'Группы'));
          const { start: date_start, end: date_end } = parseDateRange(extractLabeledValue(text, 'Период'));
          const event = extractLabeledValue(text, 'Мероприятие');
          const directions = parseList(extractLabeledValue(text, 'Направленность'));
          if (!groups.length && !date_start && !date_end && !event && !directions.length) return null;
          return { groups, date_start, date_end, event, directions };
        },
      },
      {
        key: 'participated_in_two_curator_events',
        label:
          '18. Участие не менее чем в двух мероприятиях  для кураторов: собрания, совещания,  тренинги, мастер-классы, конкурс кураторов *',
        type: 'boolean',
      },
      {
        key: 'curator_personal_events',
        label:
          '19. Даты участия не менее чем в двух мероприятиях  для кураторов: собрания, совещания, тренинги, мастер-классы, конкурс кураторов',
        type: 'list',
        parseItem: (text) => {
          const { start: date_start, end: date_end } = parseDateRange(extractLabeledValue(text, 'Период'));
          const event = extractLabeledValue(text, 'Мероприятие');
          const directions = parseList(extractLabeledValue(text, 'Направленность'));
          if (!date_start && !date_end && !event && !directions.length) return null;
          return { date_start, date_end, event, directions };
        },
      },
      {
        key: 'personal_program_participation',
        label:
          '20. Личное участие в региональных, межмуниципальных, федеральных программах, конкурсах, мероприятиях по работе с детьми и молодежью, воспитательной работе, молодежной политике (форумы, «Голос поколения», конкурс кураторов РГПУ им. Герцена и т.д.)',
        type: 'list',
        parseItem: (text) => {
          const { start: date_start, end: date_end } = parseDateRange(extractLabeledValue(text, 'Период'));
          const event = extractLabeledValue(text, 'Мероприятие');
          const directions = parseList(extractLabeledValue(text, 'Направленность'));
          if (!date_start && !date_end && !event && !directions.length) return null;
          return { date_start, date_end, event, directions };
        },
      },
      {
        key: 'mentor_support_events',
        label: '21. Участие куратора в роли наставника проекта, а также в подготовке к чемпионату, конкурсу, конференции и др.',
        type: 'list',
        parseItem: (text) => {
          const { start: date_start, end: date_end } = parseDateRange(extractLabeledValue(text, 'Период'));
          const event = extractLabeledValue(text, 'Мероприятие');
          const directions = parseList(extractLabeledValue(text, 'Направленность'));
          const group = extractLabeledValue(text, 'группа');
          const student = extractLabeledValue(text, 'студент(ы)');
          const result = extractLabeledValue(text, 'результат');
          if (!date_start && !date_end && !event && !directions.length && !group && !student && !result) return null;
          return { date_start, date_end, event, directions, group, student, result };
        },
      },
      {
        key: 'scientific_publications',
        label:
          '22. Опубликование научной работы (в том числе монографии, научной статьи, доклада, тезисов доклада и т.д. на темы, связанные с молодежной политикой и воспитательной деятельностью, с указанием принадлежности автора к ГУАП (в том числе в форме электронного издания))',
        type: 'list',
        parseItem: (text) => {
          if (!text || text === '—') return null;
          const [description, link = ''] = text.split(' — ').map((part) => part.trim());
          if (!description && !link) return null;
          return { description, link };
        },
      },
      {
        key: 'media_materials',
        label: '23. Интервью и статьи для «Дзен.ГУАП», соцсетей и сайта ГУАП',
        type: 'list',
        parseItem: (text) => {
          const directions = parseList(extractLabeledValue(text, 'Направленность'));
          const link = extractLabeledValue(text, 'Ссылка');
          if (!directions.length && !link) return null;
          return { directions, link };
        },
      },
      {
        key: 'qualification_courses',
        label: '24. Курсы повышения квалификации в области молодежной политики и воспитательной деятельности',
        type: 'list',
        parseItem: (text) => {
          const { start: date_start, end: date_end } = parseDateRange(extractLabeledValue(text, 'Период'));
          const event = extractLabeledValue(text, 'Курс');
          const directions = parseList(extractLabeledValue(text, 'Направленность'));
          if (!date_start && !date_end && !event && !directions.length) return null;
          return { date_start, date_end, event, directions };
        },
      },
    ];

    const LABEL_SPAN_LIMIT = 5;

    function matchesLabelAtIndex(lines, label, index, maxSpan = LABEL_SPAN_LIMIT) {
      let combined = '';

      for (let offset = 0; offset < maxSpan && index + offset < lines.length; offset += 1) {
        combined = combined ? `${combined} ${lines[index + offset]}`.trim() : lines[index + offset];
        if (combined.startsWith(label)) {
          return { span: offset + 1, line: combined };
        }

        if (combined.length > label.length + 50) break;
      }

      return null;
    }

    function getLabelPrefix(label, wordCount = 4) {
      return label
        .split(/\s+/)
        .slice(0, wordCount)
        .join(' ');
    }

    function findLabelPosition(lines, label, startIndex = 0, maxSpan = LABEL_SPAN_LIMIT) {
      for (let idx = startIndex; idx < lines.length; idx += 1) {
        const match = matchesLabelAtIndex(lines, label, idx, maxSpan);
        if (match) return { ...match, index: idx };
      }

      return null;
    }

    function findNextLabelIndex(lines, labels, startIndex = 0, maxSpan = LABEL_SPAN_LIMIT) {
      const prefixes = labels.map((label) => getLabelPrefix(label));

      for (let idx = startIndex; idx < lines.length; idx += 1) {
        if (labels.some((label) => matchesLabelAtIndex(lines, label, idx, maxSpan))) {
          return idx;
        }

        const normalizedLine = normalizeLine(lines[idx]);
        if (prefixes.some((prefix) => normalizedLine.startsWith(prefix))) {
          return idx;
        }
      }

      return lines.length;
    }

    function extractAnswerFromLine(line, label) {
      if (!line || !label || !line.startsWith(label)) return '';
      const remainder = line.slice(label.length).trim();
      return remainder.startsWith(':') ? remainder.slice(1).trim() : remainder;
    }

    function parseSurveyResponses(rawLines = []) {
      const normalizedLines = rawLines.map(normalizeLine).filter(Boolean);
      const result = createEmptyReportTemplate();
      delete result._comments;

      let cursor = 0;

      questionOrder.forEach((question, index) => {
        const label = normalizeLine(question.label);
        const nextLabels = questionOrder.slice(index + 1).map((item) => normalizeLine(item.label));

        const match = findLabelPosition(normalizedLines, label, cursor);
        if (!match) return;

        const { index: lineIndex, span, line } = match;
        const nextLabelIndex = findNextLabelIndex(normalizedLines, nextLabels, lineIndex + span);
        const answerPart = extractAnswerFromLine(line, label);
        const firstAnswerIndex = lineIndex + span;

        if (question.type === 'boolean') {
          const fallbackAnswer =
            normalizedLines[firstAnswerIndex] && firstAnswerIndex < nextLabelIndex
              ? normalizedLines[firstAnswerIndex]
              : '';
          const answer = answerPart || fallbackAnswer || '';
          result[question.key] = parseBooleanAnswer(answer);
          cursor = Math.max(nextLabelIndex, firstAnswerIndex);
          return;
        }

        if (question.type === 'line') {
          const fallbackAnswer =
            normalizedLines[firstAnswerIndex] && firstAnswerIndex < nextLabelIndex
              ? normalizedLines[firstAnswerIndex]
              : '';
          const answer = answerPart || fallbackAnswer || '';
          result[question.key] = answer === '—' ? '' : answer;
          cursor = Math.max(nextLabelIndex, firstAnswerIndex);
          return;
        }

        const rawItems = [];
        if (answerPart && answerPart !== '—') {
          rawItems.push(answerPart);
        }

        normalizedLines
          .slice(firstAnswerIndex, nextLabelIndex)
          .filter((item) => item && item !== '—')
          .forEach((item) => rawItems.push(item));

        const parsedItems = mergeNumberedLines(rawItems)
          .map((item) => item.replace(/^\d+\.\s*/, '').trim())
          .map((item) => (question.parseItem ? question.parseItem(item) : item || null))
          .filter(Boolean);

        result[question.key] = parsedItems;
        cursor = Math.max(nextLabelIndex, firstAnswerIndex);
      });

      return result;
    }

    function createEmptyReportTemplate() {
      return {
        _comments: {},
        reporting_period: {
          label: '',
          date_start: '',
          date_end: '',
          deadline: '',
          display: '',
        },
        full_name: '',
        job_positions: [],
        department: '',
        contact_phone_connected_to_telegram: '',
        telegram_username: '',
        email: '',
        curated_group_numbers: [],
        curator_primary_building: '',
        curator_primary_room: '',
        institute_or_faculty: [],
        held_minimum_three_curator_sessions_in_reporting_period: null,
        curator_hours_details: [],
        manages_group_chat: null,
        inform_group_about_events: null,
        achievements: [],
        participated_in_two_events_with_group: null,
        joint_participation_events: [],
        participated_in_two_curator_events: null,
        curator_personal_events: [],
        personal_program_participation: [],
        mentor_support_events: [],
        scientific_publications: [],
        media_materials: [],
        qualification_courses: [],
      };
    }

    async function convertPdfToJson(file) {
      const isPdf = file && (file.type === 'application/pdf' || /\.pdf$/i.test(file.name || ''));
      if (!isPdf) {
        setConversionState('Пожалуйста, выберите PDF-файл.', true);
        return;
      }

      setConversionState('Чтение файла...');
      const buffer = await file.arrayBuffer();

      setConversionState('Извлечение страниц...');
      const pdf = await pdfjsLib.getDocument({ data: buffer }).promise;
      const pages = [];
      const allLines = [];

      for (let pageNumber = 1; pageNumber <= pdf.numPages; pageNumber += 1) {
        setConversionState(`Обработка страницы ${pageNumber} из ${pdf.numPages}...`);
        const lines = await extractPageLines(pdf, pageNumber);
        allLines.push(...lines);
        pages.push({ page: pageNumber, text: lines.join('\n') });
      }

      const parsedData = parseSurveyResponses(allLines);
      const payload = {
        ...createEmptyReportTemplate(),
        ...parsedData,
        _comments: {
          source_pdf_file: file.name,
          page_count: pdf.numPages,
          pages,
        },
      };

      const json = JSON.stringify(payload, null, 2);
      jsonOutput.value = json;
      pageCountBadge.hidden = false;
      pageCountBadge.textContent = `Страниц: ${pdf.numPages}`;
      setConversionState('Готово! Можно скачать JSON.');
      downloadButton.disabled = false;
    }

    function resetOutput() {
      jsonOutput.value = '';
      downloadButton.disabled = true;
      pageCountBadge.hidden = true;
      setConversionState('Ожидаю загрузку файла.');
    }

    pdfInput.addEventListener('change', () => {
      const [file] = pdfInput.files || [];
      if (!file) {
        fileStatus.textContent = 'Файл не выбран';
        convertButton.disabled = true;
        resetOutput();
        return;
      }

      fileStatus.textContent = `${file.name} (${(file.size / 1024).toFixed(1)} КБ)`;
      if (!pdfJsReady) {
        setConversionState('Библиотека PDF.js не загружена. Проверьте подключение к интернету и обновите страницу.', true);
      }
      resetOutput();
      const suggestedName = generateFileName(file.name);
      outputNameInput.placeholder = suggestedName;
      updateConvertAvailability();
    });

    convertButton.addEventListener('click', () => {
      const [file] = pdfInput.files || [];
      if (!file) {
        setConversionState('Файл не выбран.', true);
        return;
      }

      if (!pdfJsReady || !pdfWorkerReady) {
        setConversionState('Библиотека PDF.js не готова. Перезагрузите страницу после восстановления подключения.', true);
        return;
      }

      downloadButton.disabled = true;
      convertPdfToJson(file).catch((error) => {
        console.error(error);
        setConversionState('Не удалось прочитать PDF. Проверьте файл и попробуйте снова.', true);
      });
    });

    downloadButton.addEventListener('click', () => {
      const [file] = pdfInput.files || [];
      if (!file || !jsonOutput.value) return;

      const blob = new Blob([jsonOutput.value], { type: 'application/json' });
      const url = URL.createObjectURL(blob);
      const link = document.createElement('a');
      link.href = url;
      const userFileName = (outputNameInput.value || outputNameInput.placeholder || generateFileName(file.name)).trim();
      link.download = userFileName || generateFileName(file.name);
      document.body.appendChild(link);
      link.click();
      link.remove();
      URL.revokeObjectURL(url);
    });
  </script>
</body>
</html>
