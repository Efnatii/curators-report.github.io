      const downloadBlob = (blob, filename) => {
        const url = URL.createObjectURL(blob);
        const link = document.createElement("a");
        link.href = url;
        link.download = filename;
        document.body.appendChild(link);
        link.click();
        link.remove();
        URL.revokeObjectURL(url);
      };

      const createWorkbookBlob = ({
        dataRows,
        merges,
        columnWidths,
        highlights,
        rowHeights,
        recordBoundaries,
        scoreColumnIndex,
      }) => {
        const worksheet = XLSX.utils.aoa_to_sheet(dataRows);
        worksheet["!merges"] = merges.map((m) => ({ s: m.s, e: m.e }));
        worksheet["!cols"] = columnWidths.map((wch) => ({ wch }));
        worksheet["!rows"] = rowHeights.map((hpt) => ({ hpt }));

        const encode = XLSX.utils.encode_cell;

        const applyStyle = (cellRef, style) => {
          const cell = worksheet[cellRef] || { t: "s", v: "" };
          cell.s = { ...(cell.s || {}), ...style };
          worksheet[cellRef] = cell;
        };
        const baseStyle = {
          alignment: { vertical: "top", horizontal: "left", wrapText: true },
        };
        const headerStyle = {
          alignment: { vertical: "top", horizontal: "left", wrapText: true },
        };
        const highlightStyle = {
          fill: { patternType: "solid", fgColor: { rgb: HIGHLIGHT_RGB } },
        };
        const separatorStyle = {
          border: {
            bottom: { style: "medium", color: { rgb: "000000" } },
          },
        };
        for (let r = 0; r < dataRows.length; r++) {
          for (let c = 0; c < dataRows[0].length; c++) {
            const hasValue = dataRows[r][c] !== undefined && dataRows[r][c] !== null;
            if (hasValue) {
              applyStyle(encode({ r, c }), baseStyle);
        }
        for (let r = 0; r < 2; r++) {
          for (let c = 0; c < dataRows[0].length; c++) {
            const hasValue = dataRows[r][c] !== "" && dataRows[r][c] !== undefined && dataRows[r][c] !== null;
            if (hasValue) {
              applyStyle(encode({ r, c }), headerStyle);
        }
        highlights.forEach(({ r, c }) => {
          applyStyle(encode({ r, c }), highlightStyle);
        });
        if (typeof scoreColumnIndex === "number" && scoreColumnIndex >= 0) {
          const c = scoreColumnIndex;
          for (let r = 2; r < dataRows.length; r++) {
            const ref = encode({ r, c });
            const cell = worksheet[ref];
            if (!cell) continue;
            const hasValue = cell.v !== undefined && cell.v !== null && cell.v !== "";
            const style = {
              alignment: { vertical: "top", horizontal: "left", wrapText: true },
              ...(hasValue ? { font: { bold: true } } : {}),
            };
            applyStyle(ref, style);
        }
        recordBoundaries.forEach(({ end }) => {
          for (let c = 0; c < dataRows[0].length; c++) {
            applyStyle(encode({ r: end, c }), separatorStyle);
          }
        });
        const wb = XLSX.utils.book_new();
        XLSX.utils.book_append_sheet(wb, worksheet, "Анкеты");
        return new Blob([arrayBuffer], {
      const handleCombineClick = async () => {
          const records = await readFiles(files);
          const workbookData = buildWorkbook(records);
          const filename = "combined.xlsx";
          const workbookBlob = createWorkbookBlob(workbookData);
          downloadBlob(workbookBlob, filename);
            const pdfBlob = new Blob([pdfContent], { type: "application/pdf" });
            downloadBlob(pdfBlob, "combined_scores.pdf");
      };

      combineBtn.addEventListener("click", handleCombineClick);
