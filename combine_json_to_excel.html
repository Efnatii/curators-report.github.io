<!DOCTYPE html>
<html lang="ru">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Сбор анкет в Excel</title>
  <link rel="stylesheet" href="styles.css" />
  <style>
    body {
      background: #0c0f16;
      color: #e9ecf2;
      font-family: "Inter", system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI", sans-serif;
      margin: 0;
      min-height: 100vh;
      display: flex;
      align-items: center;
      justify-content: center;
      padding: 24px;
    }

    .card {
      background: #0f1522;
      border: 1px solid #1f2a3d;
      border-radius: 16px;
      box-shadow: 0 12px 40px rgba(0, 0, 0, 0.35);
      max-width: 1100px;
      width: 100%;
      padding: 24px;
    }

    h1 {
      margin: 0 0 12px;
      font-size: 26px;
      color: #f2b138;
    }

    p {
      color: #b3b9c6;
      line-height: 1.6;
      margin: 4px 0 12px;
    }

    .field {
      margin: 18px 0;
      display: flex;
      flex-direction: column;
      gap: 8px;
    }

    label {
      font-weight: 600;
    }

    input[type="file"] {
      padding: 12px;
      background: #111a2b;
      border: 1px dashed #3a4b6a;
      border-radius: 12px;
      color: #e9ecf2;
    }

    .actions {
      display: flex;
      align-items: center;
      gap: 12px;
      flex-wrap: wrap;
    }

    button {
      background: linear-gradient(135deg, #f2b138, #f08b35);
      border: none;
      border-radius: 12px;
      color: #0c0f16;
      cursor: pointer;
      font-weight: 700;
      padding: 12px 18px;
      transition: transform 0.12s ease, box-shadow 0.12s ease;
    }

    button:hover {
      transform: translateY(-1px);
      box-shadow: 0 10px 20px rgba(242, 177, 56, 0.35);
    }

    button:disabled {
      background: #3a4b6a;
      color: #9aa8c2;
      cursor: not-allowed;
      box-shadow: none;
      transform: none;
    }

    .status {
      background: #111a2b;
      border: 1px solid #1f2a3d;
      border-radius: 12px;
      padding: 14px;
      min-height: 90px;
      line-height: 1.5;
      color: #dfe5f5;
    }

    .checkbox {
      display: flex;
      align-items: center;
      gap: 8px;
      color: #dfe5f5;
    }

    .checkbox input {
      width: 18px;
      height: 18px;
      accent-color: #f2b138;
    }
  </style>
</head>
<body>
  <main class="card">
    <h1>Сбор анкет в Excel</h1>
    <p>Загрузите выгрузки анкет в формате JSON, чтобы объединить их в одну книгу Excel. Дополнительно можно сформировать единый многостраничный PDF-отчёт с подробной расшифровкой баллов по каждому файлу.</p>

    <div class="field">
      <label for="jsonFiles">Выберите JSON-файлы (можно несколько):</label>
      <input id="jsonFiles" type="file" accept="application/json" multiple />
    </div>

    <div class="actions">
      <label class="checkbox"><input id="generatePdfs" type="checkbox" />Сформировать PDF по баллам</label>
      <button id="combineBtn">Собрать Excel</button>
    </div>

    <div class="field">
      <div class="status" id="status">Ожидание файлов…</div>
    </div>
  </main>

    <script>
    (async () => {
      const statusEl = document.getElementById("status");

      const questionOrder = [
        { key: "reporting_period", label: "Отчётный период", subfields: { date_start: "Дата начала", date_end: "Дата окончания" } },
        { key: "score", label: "Баллы", always: true },
        { key: "full_name", label: "1. Фамилия Имя Отчество" },
        { key: "job_positions", label: "2. Должность" },
        { key: "department", label: "3. Кафедра" },
        { key: "contact_phone_connected_to_telegram", label: "4. Контактный телефон (подключенный к Telegram)" },
        { key: "telegram_username", label: "5. Ник в Telegram" },
        { key: "email", label: "6. E-mail" },
        { key: "curated_group_numbers", label: "7. Номера курируемых групп" },
        { key: "curator_primary_building", label: "8. Корпус основного пребывания куратора" },
        { key: "curator_primary_room", label: "9. Аудитория основного пребывания куратора" },
        { key: "institute_or_faculty", label: "10. Институт/Факультет" },
        { key: "held_minimum_three_curator_sessions_in_reporting_period", label: "11. Проведение не менее трёх кураторских часов за отчётный период" },
        { key: "curator_hours_details", label: "12. Даты проведения трёх и более кураторских часов в течение отчётного периода", subfields: { groups: "Группы", date_start: "Дата начала", date_end: "Дата окончания", topic: "Тема", directions: "Направленность", specialists: "Приглашённые специалисты" } },
        { key: "manages_group_chat", label: "13. Ведение чата с каждой группой или общего чата" },
        { key: "inform_group_about_events", label: "14. Информирование группы о мероприятиях и событиях различного уровня" },
        { key: "achievements", label: "15. Призовое место обучающегося во внеучебных мероприятиях", subfields: { date_start: "Дата начала", date_end: "Дата окончания", event: "Мероприятие", group: "Группа", student: "ФИО студента", result: "Итог" } },
        { key: "participated_in_two_events_with_group", label: "16. Совместное участие с группой не менее чем в двух мероприятиях" },
        { key: "joint_participation_events", label: "17. Даты проведения двух и более мероприятий в течение отчётного периода", subfields: { groups: "Группы", date_start: "Дата начала", date_end: "Дата окончания", event: "Мероприятие" } },
        { key: "participated_in_two_curator_events", label: "18. Участие не менее чем в двух мероприятиях для кураторов" },
        { key: "curator_personal_events", label: "19. Даты участия в мероприятиях для кураторов", subfields: { date_start: "Дата начала", date_end: "Дата окончания", event: "Мероприятие" } },
        { key: "personal_program_participation", label: "20. Личное участие в программах и конкурсах", subfields: { date_start: "Дата начала", date_end: "Дата окончания", event: "Мероприятие" } },
        { key: "mentor_support_events", label: "21. Участие куратора в роли наставника проекта", subfields: { date_start: "Дата начала", date_end: "Дата окончания", event: "Мероприятие", group: "Группа", student: "ФИО студента", result: "Итог" } },
        { key: "scientific_publications", label: "22. Опубликование научной работы", subfields: { description: "Описание", link: "Ссылка" } },
        { key: "media_materials", label: "23. Интервью и статьи для \"Дзен.Гуап\", соцсетей и сайта ГУАП", subfields: { link: "Ссылка" } },
        { key: "qualification_courses", label: "24. Курсы повышения квалификации", subfields: { date_start: "Дата начала", date_end: "Дата окончания", event: "Мероприятие" } },
      ];

      const HIGHLIGHT_RGB = "FFF8DC";

      const combineBtn = document.getElementById("combineBtn");
      const fileInput = document.getElementById("jsonFiles");
      const pdfCheckbox = document.getElementById("generatePdfs");

      combineBtn.disabled = true;

      const setStatus = (message, isError = false) => {
        statusEl.textContent = message;
        statusEl.style.color = isError ? "#ffb4b4" : "#dfe5f5";
      };

      const loadScript = (src) =>
        new Promise((resolve, reject) => {
          const script = document.createElement("script");
          script.src = src;
          script.onload = resolve;
          script.onerror = () => reject(new Error(`Не удалось загрузить ${src}`));
          document.head.appendChild(script);
        });

      const loadLibrary = async (label, urls) => {
        for (const url of urls) {
          try {
            await loadScript(url);
            return;
          } catch (err) {
            console.warn(`${label} fallback failed:`, err);
          }
        }
        throw new Error(`Не удалось загрузить библиотеку ${label}. Проверьте подключение к Интернету или попробуйте снова.`);
      };

      const formatScalarList = (items) => {
        return [...items].map((item) => String(item)).sort((a, b) => a.localeCompare(b)).join(", ");
      };

      const normalizeCellValue = (value) => {
        if (value === null || typeof value === "string" || typeof value === "number" || typeof value === "boolean") {
          return value;
        }
        if (Array.isArray(value) && value.every((item) => typeof item !== "object")) {
          return formatScalarList(value);
        }
        return JSON.stringify(value, null, 2);
      };

      const normalizeReportingPeriod = (value) => {
        let date_start = null;
        let date_end = null;

        if (value && typeof value === "object" && !Array.isArray(value)) {
          date_start = value.date_start ?? null;
          date_end = value.date_end ?? null;

          if (!date_start && !date_end && typeof value.range === "string") {
            const [start, end] = value.range.split(" - ");
            if (start && end) {
              date_start = start;
              date_end = end;
            }
          }
        }

        return { date_start, date_end };
      };

      const normalizeRecordValues = (record) => {
        const normalized = {};
        for (const [key, value] of Object.entries(record)) {
          if (key === "reporting_period") {
            normalized[key] = normalizeReportingPeriod(value);
            continue;
          }

          if (Array.isArray(value) && value.every((item) => typeof item !== "object")) {
            normalized[key] = formatScalarList(value);
          } else {
            normalized[key] = value;
          }
        }
        return normalized;
      };

      const isYes = (value) => {
        if (typeof value === "boolean") return value;
        if (typeof value === "string") return value.trim().toLowerCase() === "да";
        return false;
      };

      const rowHasContent = (row) => {
        if (row && typeof row === "object" && !Array.isArray(row)) {
          return Object.values(row).some((v) => Boolean(v));
        }
        if (typeof row === "string" || typeof row === "number" || typeof row === "boolean") {
          return Boolean(row);
        }
        return false;
      };

      const countFilledRows = (value) => {
        if (!Array.isArray(value)) return 0;
        return value.reduce((sum, item) => sum + (rowHasContent(item) ? 1 : 0), 0);
      };

      const countRowsWithSpecialists = (value) => {
        if (!Array.isArray(value)) return 0;
        return value.reduce((sum, item) => {
          if (!item || typeof item !== "object" || Array.isArray(item)) return sum;
          const specialists = item.specialists;
          if (typeof specialists === "string" && specialists.trim()) return sum + 1;
          if (Array.isArray(specialists) && specialists.some(Boolean)) return sum + 1;
          return sum;
        }, 0);
      };

      const computePointComponents = (record) => {
        const value11 = record["held_minimum_three_curator_sessions_in_reporting_period"];
        const value12 = record["curator_hours_details"];
        const value13 = record["manages_group_chat"];
        const value14 = record["inform_group_about_events"];
        const value16 = record["participated_in_two_events_with_group"];
        const value17 = record["joint_participation_events"];
        const value18 = record["participated_in_two_curator_events"];
        const value19 = record["curator_personal_events"];

        const count12 = countFilledRows(value12);
        const count17 = countFilledRows(value17);
        const count19 = countFilledRows(value19);

        const components = [];

        const baseConditionMet =
          isYes(value11) &&
          count12 >= 3 &&
          isYes(value13) &&
          isYes(value14) &&
          isYes(value16) &&
          count17 >= 2 &&
          isYes(value18) &&
          count19 >= 2;

        components.push([
          "Базовое условие (пп. 11, 12, 13, 14, 16, 17, 18, 19)",
          baseConditionMet ? 30 : 0,
        ]);

        components.push([
          "Личное участие в программах и конкурсах (п.20)",
          countFilledRows(record["personal_program_participation"]) * 10,
        ]);
        components.push([
          "Опубликование научной работы (п.22)",
          countFilledRows(record["scientific_publications"]) * 20,
        ]);
        components.push([
          "Интервью/статьи для \"Дзен.Гуап\"/соцсетей/сайта ГУАП (п.23)",
          countFilledRows(record["media_materials"]) * 15,
        ]);

        components.push([
          "Курсы повышения квалификации (п.24)",
          countFilledRows(record["qualification_courses"]) * 10,
        ]);

        const achievements = record["achievements"];
        const achievementPoints = Array.isArray(achievements)
          ? achievements.reduce((sum, ach) => {
              if (!ach || typeof ach !== "object") return sum;
              const result = (ach.result || "").toLowerCase();
              if (result.includes("1") || result.includes("1 место")) return sum + 15;
              if (result.includes("2") || result.includes("2 место")) return sum + 10;
              if (result.includes("3") || result.includes("3 место")) return sum + 5;
              if (result.includes("участ")) return sum + 2;
              return sum;
            }, 0)
          : 0;
        components.push(["Призовые места обучающихся (п.15)", achievementPoints]);

        const mentorSupportPoints = Array.isArray(record["mentor_support_events"])
          ? record["mentor_support_events"].reduce((sum, item) => sum + (rowHasContent(item) ? 10 : 0), 0)
          : 0;
        components.push(["Наставничество проектов (п.21)", mentorSupportPoints]);

        const curatorHoursDetails = record["curator_hours_details"];
        const specialistCount = countRowsWithSpecialists(curatorHoursDetails);
        const specialistPoints = specialistCount > 1 ? 10 : specialistCount === 1 ? 5 : 0;
        components.push(["Приглашение специалистов на кураторские часы (п.12)", specialistPoints]);

        return components;
      };

      const computePoints = (record) => computePointComponents(record).reduce((sum, [, pts]) => sum + (Number(pts) || 0), 0);

      const escapeXml = (value) =>
        String(value)
          .replace(/&/g, "&amp;")
          .replace(/</g, "&lt;")
          .replace(/>/g, "&gt;")
          .replace(/\"/g, "&quot;")
          .replace(/\n/g, "&#10;");

      const flattenColumns = (questions) => {
        const flat = [];
        questions.forEach((q) => {
          if (q.subfields) {
            for (const [subkey, label] of Object.entries(q.subfields)) {
              flat.push({ key: `${q.key}__${subkey}`, label, parent: q.key, subkey });
            }
          } else {
            flat.push({ key: q.key, label: q.label });
          }
        });
        return flat;
      };

      const adjustColumnWidths = (data) => {
        const widths = [];
        data.forEach((row) => {
          row.forEach((value, idx) => {
            const text = value == null ? "" : String(value);
            const len = Math.max(...text.split("\n").map((line) => line.length), 0);
            widths[idx] = Math.max(widths[idx] || 0, len + 2);
          });
        });
        return widths.map((w) => Math.min(Math.max(w, 12), 60));
      };

      const determineColumns = (records) => {
        const keys = new Set();
        records.forEach(([, record]) => {
          Object.keys(record).forEach((k) => keys.add(k));
        });

        const ordered = questionOrder.filter((q) => q.always || keys.has(q.key));
        keys.forEach((key) => {
          if (!ordered.some((q) => q.key === key)) {
            ordered.push({ key, label: key });
          }
        });
        return ordered;
      };

      const buildWorkbook = (records) => {
        const questions = determineColumns(records);
        const flatColumns = flattenColumns(questions);

        const header1 = ["Файл"];
        const header2 = ["Файл"];
        const merges = [];

        let colIndex = 1;
        for (const q of questions) {
          const span = q.subfields ? q.subfields.length : 1;
          header1.push(q.label, ...Array(span - 1).fill(""));
          if (q.subfields) {
            header2.push(...q.subfields.map(([, label]) => label));
            merges.push({ s: { r: 0, c: colIndex }, e: { r: 0, c: colIndex + span - 1 } });
          } else {
            header2.push("");
          }
          colIndex += span;
        }

        const dataRows = [header1, header2];
        const highlightCells = [];

        for (const [fileName, rawRecord] of records) {
          const record = normalizeRecordValues(rawRecord);
          record.score = computePoints(record);

          const questionsToUse = questions;
          const startRow = dataRows.length;

          const maxDepth = questionsToUse.reduce((max, q) => {
            const value = record[q.key];
            if (Array.isArray(value)) {
              return Math.max(max, value.length);
            }
            return max;
          }, 1);

          for (let i = 0; i < Math.max(1, maxDepth); i++) {
            const row = [];
            row.push(i === 0 ? fileName : "");

            for (const q of questionsToUse) {
              const { key, subfields } = q;
              const value = record[key];

              if (subfields) {
                const entries = Object.entries(subfields);
                entries.forEach(([subkey], idx) => {
                  let cellValue = "";
                  if (Array.isArray(value)) {
                    const item = value[i];
                    if (item && typeof item === "object" && !Array.isArray(item)) {
                      cellValue = normalizeCellValue(item[subkey]);
                    }
                  } else if (value && typeof value === "object" && !Array.isArray(value)) {
                    cellValue = i === 0 ? normalizeCellValue(value[subkey]) : "";
                  } else if (i === 0) {
                    cellValue = normalizeCellValue(value);
                  }
                  row.push(cellValue ?? "");
                });
              } else {
                if (Array.isArray(value)) {
                  row.push(normalizeCellValue(value[i]));
                } else {
                  row.push(i === 0 ? normalizeCellValue(value) ?? "" : "");
                }
              }
            }

            dataRows.push(row);
          }

          let columnStart = 1;
          for (const q of questionsToUse) {
            const span = q.subfields ? q.subfields.length : 1;
            const value = record[q.key];
            if (Array.isArray(value) && value.length) {
              for (let offset = 0; offset < span; offset++) {
                for (let r = startRow; r < startRow + value.length; r++) {
                  highlightCells.push({ r, c: columnStart + offset });
                }
              }
            }
            columnStart += span;
          }
        }

        const columnWidths = adjustColumnWidths(dataRows);
        return { dataRows, merges, highlights: highlightCells, columnWidths };
      };

      const wrapLines = (text, maxLen = 82) => {
        const words = String(text).split(/\s+/);
        const lines = [];
        let current = "";
        for (const word of words) {
          if ((current + " " + word).trim().length > maxLen) {
            if (current) lines.push(current.trim());
            current = word;
          } else {
            current += ` ${word}`;
          }
        }
        if (current.trim()) lines.push(current.trim());
        return lines.length ? lines : [""];
      };

      const buildPdfSection = (fileName, record) => {
        const components = computePointComponents(record);
        const total = computePoints(record);

        const lines = components.flatMap(([label, points]) => {
          const wrapped = wrapLines(label, 82);
          wrapped[wrapped.length - 1] = `${wrapped[wrapped.length - 1]} — ${points}`;
          return wrapped;
        });

        lines.push("", `Итого: ${total}`);

        return { title: `Бальная расшифровка — ${fileName}`, lines };
      };

      const buildPdf = (sections) => {
        const doc = new window.jspdf.jsPDF({ unit: "pt", format: "a4" });
        const pageHeight = doc.internal.pageSize.getHeight();
        const lineHeight = 16;
        const margin = 40;

        let y = margin;

        sections.forEach(({ title, lines }, idx) => {
          if (idx > 0) doc.addPage();
          y = margin;
          doc.setFontSize(16);
          doc.text(title, margin, y);
          y += lineHeight * 1.5;

          doc.setFontSize(12);
          lines.forEach((line) => {
            if (y + lineHeight > pageHeight - margin) {
              doc.addPage();
              y = margin;
            }
            doc.text(line, margin, y);
            y += lineHeight;
          });
        });

        return doc.output("arraybuffer");
      };

      const readFiles = async (fileList) => {
        const records = [];
        for (const file of fileList) {
          const text = await file.text();
          try {
            const data = JSON.parse(text);
            if (!data || typeof data !== "object" || Array.isArray(data)) {
              throw new Error("JSON должен содержать объект верхнего уровня");
            }
            records.push([file.name, data]);
          } catch (err) {
            throw new Error(`Файл ${file.name}: ${(err && err.message) || err}`);
          }
        }
        if (!records.length) throw new Error("Не выбрано ни одного файла");
        return records;
      };

      const exportWorkbook = (dataRows, merges, columnWidths, highlights, filename) => {
        const worksheet = XLSX.utils.aoa_to_sheet(dataRows);
        worksheet["!merges"] = merges.map((m) => ({ s: m.s, e: m.e }));
        worksheet["!cols"] = columnWidths.map((wch) => ({ wch }));

        const encode = XLSX.utils.encode_cell;

        const applyStyle = (cellRef, style) => {
          const cell = worksheet[cellRef] || { t: "s", v: "" };
          cell.s = { ...(cell.s || {}), ...style };
          worksheet[cellRef] = cell;
        };

        const headerStyle = {
          fill: { fgColor: { rgb: "F2B138" } },
          font: { bold: true },
        };

        const highlightStyle = {
          fill: { fgColor: { rgb: HIGHLIGHT_RGB } },
        };

        for (let r = 0; r < 2; r++) {
          for (let c = 0; c < dataRows[0].length; c++) {
            applyStyle(encode({ r, c }), headerStyle);
          }
        }

        highlights.forEach(({ r, c }) => {
          applyStyle(encode({ r, c }), highlightStyle);
        });

        const wb = XLSX.utils.book_new();
        XLSX.utils.book_append_sheet(wb, worksheet, "Анкеты");

        const arrayBuffer = XLSX.write(wb, { bookType: "xlsx", type: "array", cellStyles: true });
        const blob = new Blob([arrayBuffer], {
          type: "application/vnd.openxmlformats-officedocument.spreadsheetml.sheet",
        });

        const url = URL.createObjectURL(blob);
        const link = document.createElement("a");
        link.href = url;
        link.download = filename;
        document.body.appendChild(link);
        link.click();
        link.remove();
        URL.revokeObjectURL(url);
      };

      const bootstrap = async () => {
        setStatus("Загружаем библиотеки…");
        await loadLibrary("XLSX", [
          "https://cdn.jsdelivr.net/npm/xlsx@0.18.5/dist/xlsx.full.min.js",
          "https://unpkg.com/xlsx@0.18.5/dist/xlsx.full.min.js",
        ]);
        await loadLibrary("jsPDF", [
          "https://cdn.jsdelivr.net/npm/jspdf@2.5.1/dist/jspdf.umd.min.js",
          "https://unpkg.com/jspdf@2.5.1/dist/jspdf.umd.min.js",
        ]);
        setStatus("Ожидание файлов…");
        combineBtn.disabled = false;
      };

      await bootstrap();

      combineBtn.addEventListener("click", async () => {
        const files = fileInput.files;
        if (!files || !files.length) {
          setStatus("Сначала выберите хотя бы один JSON-файл", true);
          return;
        }

        combineBtn.disabled = true;
        setStatus("Обработка файлов… это может занять немного времени.");

        try {
          const records = await readFiles(files);
          const { dataRows, merges, highlights, columnWidths } = buildWorkbook(records);

          const filename = "combined.xlsx";
          exportWorkbook(dataRows, merges, columnWidths, highlights, filename);

          if (pdfCheckbox.checked) {
            const pdfSections = records.map(([name, record]) => buildPdfSection(name, record));
            const pdfContent = buildPdf(pdfSections);
            const blob = new Blob([pdfContent], { type: "application/pdf" });
            const url = URL.createObjectURL(blob);
            const link = document.createElement("a");
            link.href = url;
            link.download = "combined_scores.pdf";
            document.body.appendChild(link);
            link.click();
            link.remove();
            URL.revokeObjectURL(url);
          }

          setStatus(`Готово! Сохранён файл ${filename}${pdfCheckbox.checked ? " и общий PDF-отчёт" : ""}.`);
        } catch (err) {
          console.error(err);
          setStatus(err.message || String(err), true);
        } finally {
          combineBtn.disabled = false;
        }
      });
    })();
  </script>

</body>
</html>
