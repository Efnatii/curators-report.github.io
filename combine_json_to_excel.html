<!DOCTYPE html>
<html lang="ru">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Сбор анкет в Excel</title>
  <link rel="stylesheet" href="styles.css" />
  <style>
    body {
      background: #0c0f16;
      color: #e9ecf2;
      font-family: "Inter", system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI", sans-serif;
      margin: 0;
      min-height: 100vh;
      display: flex;
      align-items: center;
      justify-content: center;
      padding: 24px;
    }

    .card {
      background: #0f1522;
      border: 1px solid #1f2a3d;
      border-radius: 16px;
      box-shadow: 0 12px 40px rgba(0, 0, 0, 0.35);
      max-width: 1100px;
      width: 100%;
      padding: 24px;
    }

    h1 {
      margin: 0 0 12px;
      font-size: 26px;
      color: #f2b138;
    }

    p {
      color: #b3b9c6;
      line-height: 1.6;
      margin: 4px 0 12px;
    }

    .field {
      margin: 18px 0;
      display: flex;
      flex-direction: column;
      gap: 8px;
    }

    label {
      font-weight: 600;
    }

    input[type="file"] {
      padding: 12px;
      background: #111a2b;
      border: 1px dashed #3a4b6a;
      border-radius: 12px;
      color: #e9ecf2;
    }

    .actions {
      display: flex;
      align-items: center;
      gap: 12px;
      flex-wrap: wrap;
    }

    button {
      background: linear-gradient(135deg, #f2b138, #f08b35);
      border: none;
      border-radius: 12px;
      color: #0c0f16;
      cursor: pointer;
      font-weight: 700;
      padding: 12px 18px;
      transition: transform 0.12s ease, box-shadow 0.12s ease;
    }

    button:hover {
      transform: translateY(-1px);
      box-shadow: 0 10px 20px rgba(242, 177, 56, 0.35);
    }

    button:disabled {
      background: #3a4b6a;
      color: #9aa8c2;
      cursor: not-allowed;
      box-shadow: none;
      transform: none;
    }

    .status {
      background: #111a2b;
      border: 1px solid #1f2a3d;
      border-radius: 12px;
      padding: 14px;
      min-height: 90px;
      line-height: 1.5;
      color: #dfe5f5;
    }

    .checkbox {
      display: flex;
      align-items: center;
      gap: 8px;
      color: #dfe5f5;
    }

    .checkbox input {
      width: 18px;
      height: 18px;
      accent-color: #f2b138;
    }
  </style>
</head>
<body>
  <main class="card">
    <h1>Сбор анкет в Excel</h1>
    <p>Загрузите выгрузки анкет в формате JSON, чтобы объединить их в одну книгу Excel. Дополнительно можно сформировать единый многостраничный PDF-отчёт с подробной расшифровкой баллов по каждому файлу.</p>

    <div class="field">
      <label for="jsonFiles">Выберите JSON-файлы (можно несколько):</label>
      <input id="jsonFiles" type="file" accept="application/json" multiple />
    </div>

    <div class="actions">
      <label class="checkbox"><input id="generatePdfs" type="checkbox" />Сформировать PDF по баллам</label>
      <button id="combineBtn">Собрать Excel</button>
    </div>

    <div class="field">
      <div class="status" id="status">Ожидание файлов…</div>
    </div>
  </main>

  <script>
    (() => {
      const statusEl = document.getElementById("status");

      const questionOrder = [
      {
        key: "reporting_period",
        label: "Отчётный период",
        subfields: {
          date_start: "Дата начала",
          date_end: "Дата окончания",
        },
      },
      { key: "score", label: "Баллы", always: true },
      { key: "full_name", label: "1. Фамилия Имя Отчество" },
      { key: "job_positions", label: "2. Должность" },
      { key: "department", label: "3. Кафедра" },
      {
        key: "contact_phone_connected_to_telegram",
        label: "4. Контактный телефон (подключенный к Telegram)",
      },
      { key: "telegram_username", label: "5. Ник в Telegram" },
      { key: "email", label: "6. E-mail" },
      { key: "curated_group_numbers", label: "7. Номера курируемых групп" },
      { key: "curator_primary_building", label: "8. Корпус основного пребывания куратора" },
      { key: "curator_primary_room", label: "9. Аудитория основного пребывания куратора" },
      { key: "institute_or_faculty", label: "10. Институт/Факультет" },
      {
        key: "held_minimum_three_curator_sessions_in_reporting_period",
        label: "11. Проведение не менее трёх кураторских часов за отчётный период",
      },
      {
        key: "curator_hours_details",
        label: "12. Даты проведения трёх и более кураторских часов в течение отчётного периода",
        subfields: {
          groups: "Группы",
          date_start: "Дата начала",
          date_end: "Дата окончания",
          topic: "Тема",
          directions: "Направленность",
          specialists: "Приглашённые специалисты",
        },
      },
      { key: "manages_group_chat", label: "13. Ведение чата с каждой группой или общего чата" },
      {
        key: "inform_group_about_events",
        label: "14. Информирование группы о мероприятиях и событиях различного уровня",
      },
      {
        key: "achievements",
        label: "15. Призовое место обучающегося во внеучебных мероприятиях",
        subfields: {
          date_start: "Дата начала",
          date_end: "Дата окончания",
          event: "Мероприятие",
          group: "Группа",
          student: "ФИО студента",
          result: "Итог",
        },
      },
      {
        key: "participated_in_two_events_with_group",
        label: "16. Совместное участие с группой не менее чем в двух мероприятиях",
      },
      {
        key: "joint_participation_events",
        label: "17. Даты проведения двух и более мероприятий в течение отчётного периода",
        subfields: {
          groups: "Группы",
          date_start: "Дата начала",
          date_end: "Дата окончания",
          event: "Мероприятие",
        },
      },
      {
        key: "participated_in_two_curator_events",
        label: "18. Участие не менее чем в двух мероприятиях для кураторов",
      },
      {
        key: "curator_personal_events",
        label: "19. Даты участия в мероприятиях для кураторов",
        subfields: {
          date_start: "Дата начала",
          date_end: "Дата окончания",
          event: "Мероприятие",
        },
      },
      {
        key: "personal_program_participation",
        label: "20. Личное участие в программах и конкурсах",
        subfields: {
          date_start: "Дата начала",
          date_end: "Дата окончания",
          event: "Мероприятие",
        },
      },
      {
        key: "mentor_support_events",
        label: "21. Участие куратора в роли наставника проекта",
        subfields: {
          date_start: "Дата начала",
          date_end: "Дата окончания",
          event: "Мероприятие",
          group: "Группа",
          student: "ФИО студента",
          result: "Итог",
        },
      },
      {
        key: "scientific_publications",
        label: "22. Опубликование научной работы",
        subfields: {
          description: "Описание",
          link: "Ссылка",
        },
      },
      {
        key: "media_materials",
        label: "23. Интервью и статьи для \"Дзен.Гуап\", соцсетей и сайта ГУАП",
        subfields: { link: "Ссылка" },
      },
      {
        key: "qualification_courses",
        label: "24. Курсы повышения квалификации",
        subfields: {
          date_start: "Дата начала",
          date_end: "Дата окончания",
          event: "Мероприятие",
        },
      },
    ];

    const HIGHLIGHT_RGB = "FFF8DC";

    const combineBtn = document.getElementById("combineBtn");
    const fileInput = document.getElementById("jsonFiles");
    const pdfCheckbox = document.getElementById("generatePdfs");

    const setStatus = (message, isError = false) => {
      statusEl.textContent = message;
      statusEl.style.color = isError ? "#ffb4b4" : "#dfe5f5";
    };

    const formatScalarList = (items) => {
      return [...items].map((item) => String(item)).sort((a, b) => a.localeCompare(b)).join(", ");
    };

    const normalizeCellValue = (value) => {
      if (value === null || typeof value === "string" || typeof value === "number" || typeof value === "boolean") {
        return value;
      }
      if (Array.isArray(value) && value.every((item) => typeof item !== "object")) {
        return formatScalarList(value);
      }
      return JSON.stringify(value, null, 2);
    };

    const normalizeReportingPeriod = (value) => {
      let date_start = null;
      let date_end = null;

      if (value && typeof value === "object" && !Array.isArray(value)) {
        date_start = value.date_start ?? null;
        date_end = value.date_end ?? null;

        if (!date_start && !date_end && typeof value.range === "string") {
          const [start, end] = value.range.split(" - ");
          if (start && end) {
            date_start = start;
            date_end = end;
          }
        }
      }

      return { date_start, date_end };
    };

    const normalizeRecordValues = (record) => {
      const normalized = {};
      for (const [key, value] of Object.entries(record)) {
        if (key === "reporting_period") {
          normalized[key] = normalizeReportingPeriod(value);
          continue;
        }

        if (Array.isArray(value) && value.every((item) => typeof item !== "object")) {
          normalized[key] = formatScalarList(value);
        } else {
          normalized[key] = value;
        }
      }
      return normalized;
    };

    const isYes = (value) => {
      if (typeof value === "boolean") return value;
      if (typeof value === "string") return value.trim().toLowerCase() === "да";
      return false;
    };

    const rowHasContent = (row) => {
      if (row && typeof row === "object" && !Array.isArray(row)) {
        return Object.values(row).some((v) => Boolean(v));
      }
      if (typeof row === "string" || typeof row === "number" || typeof row === "boolean") {
        return Boolean(row);
      }
      return false;
    };

    const countFilledRows = (value) => {
      if (!Array.isArray(value)) return 0;
      return value.reduce((sum, item) => sum + (rowHasContent(item) ? 1 : 0), 0);
    };

    const countRowsWithSpecialists = (value) => {
      if (!Array.isArray(value)) return 0;
      return value.reduce((sum, item) => {
        if (!item || typeof item !== "object" || Array.isArray(item)) return sum;
        const specialists = item.specialists;
        if (typeof specialists === "string" && specialists.trim()) return sum + 1;
        if (Array.isArray(specialists) && specialists.some(Boolean)) return sum + 1;
        return sum;
      }, 0);
    };

    const computePointComponents = (record) => {
      const value11 = record["held_minimum_three_curator_sessions_in_reporting_period"];
      const value12 = record["curator_hours_details"];
      const value13 = record["manages_group_chat"];
      const value14 = record["inform_group_about_events"];
      const value16 = record["participated_in_two_events_with_group"];
      const value17 = record["joint_participation_events"];
      const value18 = record["participated_in_two_curator_events"];
      const value19 = record["curator_personal_events"];

      const count12 = countFilledRows(value12);
      const count17 = countFilledRows(value17);
      const count19 = countFilledRows(value19);

      const components = [];

      const baseConditionMet =
        isYes(value11) &&
        count12 >= 3 &&
        isYes(value13) &&
        isYes(value14) &&
        isYes(value16) &&
        count17 >= 2 &&
        isYes(value18) &&
        count19 >= 2;

      components.push([
        "Базовое условие (пп. 11, 12, 13, 14, 16, 17, 18, 19)",
        baseConditionMet ? 30 : 0,
      ]);

      components.push([
        "Личное участие в программах и конкурсах (п.20)",
        countFilledRows(record["personal_program_participation"]) * 10,
      ]);
      components.push([
        "Опубликование научной работы (п.22)",
        countFilledRows(record["scientific_publications"]) * 20,
      ]);
      components.push([
        "Интервью и статьи для \"Дзен.Гуап\" и соцсетей (п.23)",
        countFilledRows(record["media_materials"]) * 10,
      ]);
      components.push([
        "Наставничество в проектах (п.21)",
        countFilledRows(record["mentor_support_events"]) * 10,
      ]);
      components.push([
        "Призовые места обучающихся (п.15)",
        countFilledRows(record["achievements"]) * 10,
      ]);
      components.push([
        "Курсы повышения квалификации (п.24)",
        countFilledRows(record["qualification_courses"]) * 20,
      ]);
      components.push([
        "Приглашённые специалисты на кураторских часах (п.12)",
        countRowsWithSpecialists(value12) * 20,
      ]);
      components.push([
        "Дополнительные кураторские часы сверх трёх (п.12)",
        count12 > 3 ? (count12 - 3) * 5 : 0,
      ]);
      components.push([
        "Совместные мероприятия с группой сверх двух (п.17)",
        count17 > 2 ? (count17 - 2) * 5 : 0,
      ]);
      components.push([
        "Участие в мероприятиях для кураторов сверх двух (п.19)",
        count19 > 2 ? (count19 - 2) * 5 : 0,
      ]);
      components.push([
        "Курсовые/ВКР с оценкой 5 (п.13)",
        countFilledRows(record["curator_supervised_thesis"]) * 10,
      ]);
      components.push([
        "Участие студентов в НИР/НИОКР, публикации (п.13)",
        countFilledRows(record["students_in_research"]) * 10,
      ]);
      components.push([
        "Достижения выпускников (п.13)",
        countFilledRows(record["alumni_achievements"]) * 10,
      ]);

      return components;
    };

    const computePoints = (record) => {
      return computePointComponents(record).reduce((total, [, points]) => total + points, 0);
    };

    const determineColumns = (records) => {
      const presentKeys = new Set(records.flatMap(([, rec]) => Object.keys(rec)));
      const columns = [];

      for (const question of questionOrder) {
        const key = question.key;
        const alwaysInclude = Boolean(question.always);
        if (!alwaysInclude && !presentKeys.has(key)) continue;

        const subfields = question.subfields ? Object.entries(question.subfields) : null;
        columns.push({ key, label: question.label, subfields });
      }
      return columns;
    };

    const flattenColumns = (questions) => {
      const flat = [];
      for (const q of questions) {
        if (q.subfields && q.subfields.length) {
          for (const [subkey, sublabel] of q.subfields) {
            flat.push({ key: q.key, subkey, label: sublabel, parent: q.label });
          }
        } else {
          flat.push({ key: q.key, subkey: null, label: q.label, parent: q.label });
        }
      }
      return flat;
    };

    const adjustColumnWidths = (data) => {
      const widths = [];
      data.forEach((row) => {
        row.forEach((value, idx) => {
          const text = value == null ? "" : String(value);
          const len = Math.max(...text.split("\n").map((line) => line.length), 0);
          widths[idx] = Math.max(widths[idx] || 0, len + 2);
        });
      });
      return widths.map((w) => Math.min(Math.max(w, 12), 60));
    };

    const escapeXml = (value) =>
      String(value)
        .replace(/&/g, "&amp;")
        .replace(/</g, "&lt;")
        .replace(/>/g, "&gt;")
        .replace(/\"/g, "&quot;")
        .replace(/\n/g, "&#10;");

    const buildSpreadsheetXml = (rows, merges, highlights) => {
      const columnWidths = adjustColumnWidths(rows);

      const mergeMap = new Map();
      const skipCells = new Set();
      merges.forEach(({ s, e }) => {
        const across = e.c - s.c;
        const down = e.r - s.r;
        mergeMap.set(`${s.r}:${s.c}`, { across, down });
        for (let r = s.r; r <= e.r; r++) {
          for (let c = s.c; c <= e.c; c++) {
            if (r === s.r && c === s.c) continue;
            skipCells.add(`${r}:${c}`);
          }
        }
      });

      const highlightSet = new Set(highlights.map(({ r, c }) => `${r}:${c}`));

      const columnsXml = columnWidths
        .map((wch) => `<Column ss:Width="${Math.round(wch * 7)}" ss:AutoFitWidth="1" />`)
        .join("");

      const rowsXml = rows
        .map((row, rIdx) => {
          const cells = row
            .map((value, cIdx) => {
              const key = `${rIdx}:${cIdx}`;
              if (skipCells.has(key)) return "";

              const merge = mergeMap.get(key);
              const attrs = [];
              if (merge) {
                if (merge.across) attrs.push(`ss:MergeAcross="${merge.across}"`);
                if (merge.down) attrs.push(`ss:MergeDown="${merge.down}"`);
              }

              const isHeader = rIdx < 2;
              const style = isHeader ? "Header" : highlightSet.has(key) ? "Highlight" : null;
              if (style) attrs.push(`ss:StyleID="${style}"`);

              const normalized = value == null ? "" : value;
              const num = typeof normalized === "number" || (typeof normalized === "string" && normalized.trim() !== "" && !Number.isNaN(Number(normalized)))
                ? Number(normalized)
                : null;
              const type = num !== null && normalized !== "" ? "Number" : "String";
              const content = type === "Number" ? num : escapeXml(normalized);

              return `<Cell ${attrs.join(" ")}><Data ss:Type="${type}">${content}</Data></Cell>`;
            })
            .join("");
          return `<Row>${cells}</Row>`;
        })
        .join("");

      return `<?xml version="1.0"?>` +
        `<?mso-application progid="Excel.Sheet"?>` +
        `<Workbook xmlns="urn:schemas-microsoft-com:office:spreadsheet" xmlns:o="urn:schemas-microsoft-com:office:office" xmlns:x="urn:schemas-microsoft-com:office:excel" xmlns:ss="urn:schemas-microsoft-com:office:spreadsheet" xmlns:html="http://www.w3.org/TR/REC-html40">` +
        `<Styles>` +
        `<Style ss:ID="Default" ss:Name="Normal"><Alignment ss:Vertical="Center"/><Font ss:FontName="Arial" ss:Size="10"/></Style>` +
        `<Style ss:ID="Header"><Font ss:FontName="Arial" ss:Size="10" ss:Bold="1"/><Interior ss:Color="#f2b138" ss:Pattern="Solid"/></Style>` +
        `<Style ss:ID="Highlight"><Interior ss:Color="#fff8dc" ss:Pattern="Solid"/></Style>` +
        `</Styles>` +
        `<Worksheet ss:Name="Анкеты">` +
        `<Table>${columnsXml}${rowsXml}</Table>` +
        `</Worksheet>` +
        `</Workbook>`;
    };

    const escapePdfText = (text) =>
      String(text)
        .replace(/\\/g, "\\\\")
        .replace(/\(/g, "\\(")
        .replace(/\)/g, "\\)");

    const wrapLines = (text, maxLen = 90) => {
      const words = String(text).split(/\s+/);
      const lines = [];
      let current = "";
      for (const word of words) {
        if ((current + " " + word).trim().length > maxLen) {
          if (current) lines.push(current.trim());
          current = word;
        } else {
          current += ` ${word}`;
        }
      }
      if (current.trim()) lines.push(current.trim());
      return lines.length ? lines : [""];
    };

    const buildPdf = (sections) => {
      const pageWidth = 595.28; // A4 portrait in points
      const pageHeight = 841.89;
      const margin = 40;
      const lineHeight = 16;

      const pages = [];
      let y = pageHeight - margin;
      let current = [];

      const ensureSpace = (needed = lineHeight) => {
        if (y < margin + needed) {
          pages.push(current.join("\n"));
          current = [];
          y = pageHeight - margin;
        }
      };

      const addTitle = (title) => {
        ensureSpace(lineHeight * 2);
        current.push(`BT`, `/F1 16 Tf`, `1 0 0 1 ${margin} ${y} Tm`, `(${escapePdfText(title)}) Tj`, `ET`);
        y -= lineHeight * 2;
      };

      const addLine = (line) => {
        ensureSpace(lineHeight);
        current.push(`BT`, `/F1 12 Tf`, `1 0 0 1 ${margin} ${y} Tm`, `(${escapePdfText(line)}) Tj`, `ET`);
        y -= lineHeight;
      };

      sections.forEach(({ title, lines }, idx) => {
        addTitle(title);
        lines.forEach((line) => addLine(line));
        if (idx < sections.length - 1) {
          addLine("");
        }
      });

      if (current.length) pages.push(current.join("\n"));

      const objects = [];
      const offsets = [];
      const pushObject = (content) => {
        offsets.push(objects.join("").length);
        objects.push(`${objects.length + 1} 0 obj\n${content}\nendobj\n`);
      };

      pushObject(`<< /Type /Catalog /Pages 2 0 R >>`); // 1
      pushObject(`<< /Type /Pages /Count ${pages.length} /Kids [${pages
        .map((_, idx) => `${idx + 3} 0 R`)
        .join(" ")}] >>`); // 2

      pages.forEach((content, idx) => {
        const contentIndex = objects.length + pages.length + 2; // anticipate font + streams
        pushObject(`<< /Type /Page /Parent 2 0 R /MediaBox [0 0 ${pageWidth.toFixed(2)} ${pageHeight.toFixed(2)}] /Resources << /Font << /F1 5 0 R >> >> /Contents ${contentIndex + idx} 0 R >>`);
      });

      pushObject(`<< /Type /Font /Subtype /Type1 /BaseFont /Helvetica >>`); // 5 (after pages)

      pages.forEach((content) => {
        const stream = `<< /Length ${content.length} >>\nstream\n${content}\nendstream`;
        pushObject(stream);
      });

      const xrefStart = objects.join("").length;
      const header = "%PDF-1.4\n";
      let body = "";
      const xref = ["xref", `0 ${objects.length + 1}`, "0000000000 65535 f ", offsets
        .map((offset) => `${String(offset + header.length).padStart(10, "0")} 00000 n `)
        .join("\n"),
        "trailer",
        `<< /Size ${objects.length + 1} /Root 1 0 R >>`,
        "startxref",
        `${xrefStart + header.length}`,
        "%%EOF",
      ].join("\n");

      body = objects.join("");
      return header + body + xref;
    };

    const buildWorkbook = (records) => {
      const questions = determineColumns(records);
      const flatColumns = flattenColumns(questions);

      const header1 = ["Файл"];
      const header2 = ["Файл"];
      const merges = [];

      let colIndex = 1;
      for (const q of questions) {
        const span = q.subfields ? q.subfields.length : 1;
        header1.push(q.label, ...Array(span - 1).fill(""));
        if (q.subfields) {
          header2.push(...q.subfields.map(([, label]) => label));
          merges.push({ s: { r: 0, c: colIndex }, e: { r: 0, c: colIndex + span - 1 } });
        } else {
          header2.push("");
          merges.push({ s: { r: 0, c: colIndex }, e: { r: 1, c: colIndex } });
        }
        colIndex += span;
      }

      const dataRows = [header1, header2];
      const highlightCells = [];

      for (const [path, rawRecord] of records) {
        const record = normalizeRecordValues(rawRecord);
        record.score = computePoints(rawRecord);

        const blockHeight = Math.max(
          ...Object.values(record).map((value) => (Array.isArray(value) ? value.length : 1)),
          1
        );

        const startRow = dataRows.length;

        for (let offset = 0; offset < blockHeight; offset++) {
          const row = [offset === 0 ? path : ""];

          for (const { key, subkey } of flatColumns) {
            const value = record[key];
            let cellValue = "";

            if (Array.isArray(value)) {
              if (offset < value.length) {
                const item = value[offset];
                if (subkey && item && typeof item === "object" && !Array.isArray(item)) {
                  cellValue = normalizeCellValue(item[subkey]);
                } else if (!subkey) {
                  cellValue = normalizeCellValue(item);
                }
              }
            } else if (value && typeof value === "object" && !Array.isArray(value)) {
              if (subkey) {
                cellValue = offset === 0 ? normalizeCellValue(value[subkey]) : "";
              } else {
                cellValue = offset === 0 ? normalizeCellValue(value) : "";
              }
            } else if (!subkey) {
              cellValue = offset === 0 ? normalizeCellValue(value) : "";
            }

            row.push(cellValue ?? "");
          }

          dataRows.push(row);
        }

        let columnStart = 1;
        for (const q of questions) {
          const span = q.subfields ? q.subfields.length : 1;
          const value = record[q.key];
          if (Array.isArray(value) && value.length) {
            for (let offset = 0; offset < span; offset++) {
              for (let r = startRow; r < startRow + value.length; r++) {
                highlightCells.push({ r, c: columnStart + offset });
              }
            }
          }
          columnStart += span;
        }
      }

      const workbookXml = buildSpreadsheetXml(dataRows, merges, highlightCells);
      return { workbookXml, dataRows };
    };

    const downloadWorkbook = (xml, filename) => {
      const blob = new Blob([xml], { type: "application/vnd.ms-excel" });
      const url = URL.createObjectURL(blob);
      const link = document.createElement("a");
      link.href = url;
      link.download = filename;
      document.body.appendChild(link);
      link.click();
      link.remove();
      URL.revokeObjectURL(url);
    };

    const buildPdfSection = (fileName, record) => {
      const components = computePointComponents(record);
      const total = computePoints(record);

      const lines = components.flatMap(([label, points]) => {
        const wrapped = wrapLines(label, 82);
        wrapped[wrapped.length - 1] = `${wrapped[wrapped.length - 1]} — ${points}`;
        return wrapped;
      });

      lines.push("", `Итого: ${total}`);

      return { title: `Бальная расшифровка — ${fileName}`, lines };
    };

    const readFiles = async (fileList) => {
      const records = [];
      for (const file of fileList) {
        const text = await file.text();
        try {
          const data = JSON.parse(text);
          if (!data || typeof data !== "object" || Array.isArray(data)) {
            throw new Error("JSON должен содержать объект верхнего уровня");
          }
          records.push([file.name, data]);
        } catch (err) {
          throw new Error(`Файл ${file.name}: ${(err && err.message) || err}`);
        }
      }
      if (!records.length) throw new Error("Не выбрано ни одного файла");
      return records;
    };

    combineBtn.addEventListener("click", async () => {
      const files = fileInput.files;
      if (!files || !files.length) {
        setStatus("Сначала выберите хотя бы один JSON-файл", true);
        return;
      }

      combineBtn.disabled = true;
      setStatus("Обработка файлов… это может занять немного времени.");

      try {
        const records = await readFiles(files);
        const { workbookXml } = buildWorkbook(records);
        const filename = "combined.xls";
        downloadWorkbook(workbookXml, filename);

        if (pdfCheckbox.checked) {
          const pdfSections = records.map(([name, record]) => buildPdfSection(name, record));
          const pdfContent = buildPdf(pdfSections);
          const blob = new Blob([pdfContent], { type: "application/pdf" });
          const url = URL.createObjectURL(blob);
          const link = document.createElement("a");
          link.href = url;
          link.download = "combined_scores.pdf";
          document.body.appendChild(link);
          link.click();
          link.remove();
          URL.revokeObjectURL(url);
        }

        setStatus(`Готово! Сохранён файл ${filename}${pdfCheckbox.checked ? " и общий PDF-отчёт" : ""}.`);
      } catch (err) {
        console.error(err);
        setStatus(err.message || String(err), true);
      } finally {
        combineBtn.disabled = false;
      }
    });
    })();
  </script>
</body>
</html>
